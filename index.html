<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Pokémon Team Generator</title>
<style>
  body { font-family: Arial, sans-serif; max-width: 600px; margin: 20px auto; padding: 0 10px; }
  label { display: block; margin: 10px 0 5px; }
  button { margin-top: 15px; padding: 8px 12px; cursor: pointer; }
  pre { background: #f4f4f4; padding: 10px; white-space: pre-wrap; margin-top: 10px; }
</style>
</head>
<body>
<h1>Pokémon Team Generator</h1>

<label>Generation (1-9):
  <input id="generation" type="number" min="1" max="9" value="1" />
</label>

<label>
  <input id="fullyEvolved" type="checkbox" />
  Only fully evolved Pokémon
</label>

<label>
  <input id="randomizeEVs" type="checkbox" />
  Randomize EVs
</label>

<label>
  <input id="randomizeItems" type="checkbox" />
  Randomize Held Items
</label>


<button id="generateBtn">Generate Team</button>
<button id="exportBtn" style="display:none;">Export Showdown Format</button>

<pre id="output"></pre>

<script>
const pokeApiBase = 'https://pokeapi.co/api/v2';

async function fetchJson(url) {
  const res = await fetch(url);
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  return res.json();
}

async function getGenerationPokemon(gen) {
  const data = await fetchJson(`${pokeApiBase}/generation/${gen}`);
  return data.pokemon_species.map(species => ({
    name: species.name,
    url: species.url,
  }));
}

function pickRandom(arr, n) {
  const result = [];
  const copy = [...arr];
  const limit = Math.min(n, copy.length);
  for (let i = 0; i < limit; i++) {
    const idx = Math.floor(Math.random() * copy.length);
    result.push(copy[idx]);
    copy.splice(idx, 1);
  }
  return result;
}

async function getPokemonData(name) {
  try {
    const data = await fetchJson(`${pokeApiBase}/pokemon/${name}`);
    return {
      name: data.name,
      moves: data.moves.map(m => m.move.name),
      abilities: data.abilities.map(a => a.ability.name),
    };
  } catch (err) {
    console.warn(`Failed to fetch data for ${name}: ${err.message}`);
    return null;
  }
}

function getFinalEvolutions(chain) {
  // Recursive function to find all final species names in the evolution chain
  if (!chain.evolves_to || chain.evolves_to.length === 0) {
    return [chain.species.name];
  }
  let finals = [];
  for (const evo of chain.evolves_to) {
    finals = finals.concat(getFinalEvolutions(evo));
  }
  return finals;
}


async function fetchEvolutionChains(speciesList) {
  // Map from evo chain url to array of species names that are final evolutions
  const evoChainMap = new Map();

  // Get all unique evolution_chain urls
  const evoUrls = new Set();
  const speciesToEvoUrl = {};

  // Fetch species data in parallel
  const speciesDataArr = await Promise.all(
    speciesList.map(s => fetchJson(`${pokeApiBase}/pokemon-species/${s.name}`))
  );

  speciesDataArr.forEach(speciesData => {
    const evoUrl = speciesData.evolution_chain.url;
    evoUrls.add(evoUrl);
    speciesToEvoUrl[speciesData.name] = evoUrl;
  });

  // Fetch all evolution chains in parallel
  const evoChains = await Promise.all(
    [...evoUrls].map(url => fetchJson(url))
  );

  // Parse all final evolutions
  evoChains.forEach((chainData, i) => {
    const url = [...evoUrls][i];
    const finals = getFinalEvolutions(chainData.chain);
    evoChainMap.set(url, finals);
  });

  // Return a map: species name => boolean if fully evolved
  const evoInfoMap = {}; // { speciesName: { isFinal: bool, hasEvolutions: bool } }

  for (const s of speciesList) {
    const evoUrl = speciesToEvoUrl[s.name];
    const finalForms = evoChainMap.get(evoUrl);
    const isFinal = finalForms.includes(s.name);
    const hasEvolutions = finalForms.length > 0 && !isFinal;
    evoInfoMap[s.name] = {
      isFinal,
      hasEvolutions
  };
}

  return evoInfoMap;
}

// Modified generateTeam to use this:

async function generateTeam(gen, onlyFullyEvolved, randomizeEVs, randomizeItems) {
  let speciesList = await getGenerationPokemon(gen);

  let evoInfoMap = null;
  if (onlyFullyEvolved || randomizeItems) {
    // Need this map for item legality too
    evoInfoMap = await fetchEvolutionChains(speciesList);
    if (onlyFullyEvolved) {
      speciesList = speciesList.filter(s => evoInfoMap[s.name]);
    }
  }

  speciesList = speciesList.sort(() => Math.random() - 0.5);

  const sampleSize = Math.min(speciesList.length, 40);
  const sample = speciesList.slice(0, sampleSize);

  const batchSize = 10;
  let team = [];
  for (let i = 0; i < sample.length && team.length < 6; i += batchSize) {
    const batch = sample.slice(i, i + batchSize);
    const datas = await Promise.all(batch.map(s => getPokemonData(s.name)));
    for (const data of datas) {
      if (!data) continue;
      const moves = pickRandom(data.moves, 4);
      const ability = pickRandom(data.abilities, 1)[0];
      const speciesName = data.name.toLowerCase();
      const evoInfo = evoInfoMap ? evoInfoMap[speciesName] : { isFinal: false, hasEvolutions: true };
      const isFullyEvolved = evoInfo.isFinal;
      const canEvolve = evoInfo.hasEvolutions;
      const item = randomizeItems ? randomItem(isFullyEvolved, canEvolve) : '[Item]';




      team.push({
        name: capitalize(data.name),
        moves,
        ability,
        evs: randomizeEVs ? randomEVSpread() : '252 Atk / 252 Spe / 4 HP',
        nature: randomizeEVs ? randomNature() : 'Adamant',
        item: randomizeItems ? randomItem(!isFullyEvolved) : '[Item]'
      });

      if (team.length >= 6) break;
    }
  }

  if (team.length < 6) {
    throw new Error('Not enough Pokémon to generate a full team');
  }

  return team;
}




function capitalize(s) {
  return s.charAt(0).toUpperCase() + s.slice(1);
}

function randomEVSpread() {
  const stats = ['HP', 'Atk', 'Def', 'SpA', 'SpD', 'Spe'];
  const evs = {};
  let remaining = 508;

  stats.forEach(stat => evs[stat] = 0);

  while (remaining > 0) {
    const stat = stats[Math.floor(Math.random() * stats.length)];
    const add = Math.min(remaining, Math.floor(Math.random() * 64));
    if (evs[stat] + add <= 252) {
      evs[stat] += add;
      remaining -= add;
    }
  }

  return stats.filter(s => evs[s] > 0).map(s => `${evs[s]} ${s}`).join(' / ');
}

function randomNature() {
  const natures = [
    'Adamant', 'Modest', 'Jolly', 'Timid', 'Brave', 'Calm', 'Impish', 'Bold',
    'Careful', 'Hardy', 'Hasty', 'Lonely', 'Mild', 'Naive', 'Quiet', 'Rash',
    'Relaxed', 'Sassy', 'Serious', 'Docile', 'Lax', 'Gentle', 'Bashful', 'Quirky', 'Naughty'
  ];
  return natures[Math.floor(Math.random() * natures.length)];
}

function randomItem(isFullyEvolved, canEvolve) {
  const items = [
    'Leftovers', 'Choice Band', 'Choice Specs', 'Life Orb',
    'Focus Sash', 'Assault Vest', 'Rocky Helmet',
    'Sitrus Berry', 'Expert Belt', 'Air Balloon',
    'Black Sludge', 'Choice Scarf', 'Lum Berry', 'Light Clay',
    'Eviolite'
  ];

  const legalItems = (!isFullyEvolved && canEvolve)
    ? items
    : items.filter(i => i !== 'Eviolite');

  return legalItems[Math.floor(Math.random() * legalItems.length)];
}




function showdownFormat(team) {
  return team.map(poke => {
    return `${poke.name} @ ${poke.item}
Ability: ${capitalize(poke.ability)}
Level: 100
EVs: ${poke.evs}
Nature: ${poke.nature}
- ${poke.moves.map(capitalize).join('\n- ')}`;
  }).join('\n\n');
}


const output = document.getElementById('output');
const generateBtn = document.getElementById('generateBtn');
const exportBtn = document.getElementById('exportBtn');

let currentTeam = null;

generateBtn.onclick = async () => {
  output.textContent = 'Generating team, please wait...';
  exportBtn.style.display = 'none';
  currentTeam = null;

  const gen = parseInt(document.getElementById('generation').value);
  const onlyFullyEvolved = document.getElementById('fullyEvolved').checked;
  const randomizeEVs = document.getElementById('randomizeEVs').checked;
  const randomizeItems = document.getElementById('randomizeItems').checked;

  try {
    const team = await generateTeam(gen, onlyFullyEvolved, randomizeEVs, randomizeItems);
    if (team.length < 6) {
      output.textContent = 'Could not generate full team (not enough Pokémon matching criteria).';
      return;
    }
    currentTeam = team;
    let displayText = '';
    team.forEach((poke, idx) => {
      displayText += `${idx + 1}. ${poke.name}\nItem: ${poke.item}\nAbility: ${poke.ability}\nEVs: ${poke.evs}\nNature: ${poke.nature}\nMoves: ${poke.moves.join(', ')}\n\n`;
    });

    output.textContent = displayText;
    exportBtn.style.display = 'inline-block';
  } catch (err) {
    output.textContent = 'Error: ' + err.message;
  }
};

exportBtn.onclick = () => {
  if (!currentTeam) return;
  const text = showdownFormat(currentTeam);
  const blob = new Blob([text], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'pokemon_team.txt';
  a.click();
  URL.revokeObjectURL(url);
};
</script>
</body>
</html>
